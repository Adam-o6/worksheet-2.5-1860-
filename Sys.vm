/***************************************
 * Sys.xor
 * Computes the bitwise exclusive-or (XOR) of the two values
 * at the top of the stack.
 * (a XOR b = (a OR b) AND (NOT (a AND b)))
 ***************************************/
function Sys.xor 0
  // Pop the two values from the stack.
  pop temp 0       // b
  pop temp 1       // a

  // Compute (a OR b).
  push temp 1      // a
  push temp 0      // b
  or
  pop temp 2       // temp 2 = a OR b

  // Compute (a AND b) and then NOT it.
  push temp 1      // a
  push temp 0      // b
  and
  not

  // Compute final result: (a OR b) AND (NOT (a AND b))
  push temp 2
  and
  return

/***************************************
 * Sys.shiftLeft
 * Shifts the first argument left by the number of positions
 * specified by the second argument.
 * (x << y) is equivalent to x * 2^y.
 ***************************************/
function Sys.shiftLeft 2
  // local 0: result, local 1: counter
  push argument 0
  pop local 0      // result = x

  push argument 1
  pop local 1      // counter = y

  label SHIFT_LOOP
    // If counter == 0, we are done.
    push local 1
    push constant 0
    eq
    if-goto SHIFT_END

    // Double the result (result = result + result).
    push local 0
    push local 0
    add
    pop local 0

    // Decrement counter.
    push local 1
    push constant 1
    sub
    pop local 1

    goto SHIFT_LOOP
  label SHIFT_END
  push local 0     // Push the final shifted result.
  return

/***************************************
 * Sys.computeParity
 * Computes the parity (0 if an even number of 1's, 1 if odd)
 * of the 15 right-most bits of the input.
 * The most-significant (16th) bit is ignored.
 ***************************************/
function Sys.computeParity 4
  // local 2 will hold the input value.
  pop local 2      // input value

  // local 0: parity (initialize to 0)
  push constant 0
  pop local 0

  // local 1: loop counter i (initialize to 0)
  push constant 0
  pop local 1

  label PARITY_LOOP
    // If i == 15, exit loop.
    push local 1
    push constant 15
    eq
    if-goto PARITY_END

    // Compute bitmask = 1 << i using Sys.shiftLeft.
    push constant 1
    push local 1
    call Sys.shiftLeft 2   // Returns (1 << i).
    pop local 3             // local 3 = bitmask

    // Check if the i-th bit of input is set:
    // Compute: input AND bitmask.
    push local 2
    push local 3
    and
    // If nonzero, jump to toggle parity.
    if-goto TOGGLE_PARITY
    // Otherwise, continue loop.
    goto PARITY_CONTINUE

  label TOGGLE_PARITY
    // Toggle parity: parity = parity XOR 1.
    push local 0
    push constant 1
    call Sys.xor 2
    pop local 0           // Update parity.
  label PARITY_CONTINUE
    // Increment i.
    push local 1
    push constant 1
    add
    pop local 1
    goto PARITY_LOOP
  label PARITY_END
  push local 0           // Push computed parity as result.
  return

/***************************************
 * Sys.encode
 * Encodes an input value by computing the parity of its lower 15 bits,
 * then setting (if parity == 1) or clearing (if parity == 0)
 * the most-significant bit (bit 15). That is, if the computed parity is 1,
 * then the function sets bit 15; otherwise, it clears bit 15.
 ***************************************/
function Sys.encode 0
  // Save the input value in local 0.
  pop local 0      // local 0 = input

  // Compute parity of the lower 15 bits.
  push local 0
  call Sys.computeParity 1
  pop temp 0      // temp 0 = parity (0 or 1)

  // Prepare mask for the MSB: 1 << 15 = 32768.
  push constant 32768
  pop temp 1      // temp 1 = mask

  // If parity is 0, clear the MSB; otherwise, set the MSB.
  push temp 0
  push constant 0
  eq
  if-goto ENCODE_CLEAR
    // Parity is 1: set MSB by ORing with mask.
    push local 0
    push temp 1
    or
    goto ENCODE_DONE
  label ENCODE_CLEAR
    // Parity is 0: clear MSB by ANDing with NOT mask.
    push local 0
    push temp 1
    not
    and
  label ENCODE_DONE
  return

/***************************************
 * Sys.init
 * Test code: Uncomment one test section at a time to run that test.
 ***************************************/
function Sys.init 0
  // --- Test Sys.xor ---
  // Expected result: 10 (00000000 00001010)
  // push constant 12    // 00000000 00001100
  // push constant 6     // 00000000 00000110
  // call Sys.xor 2

  // --- Test Sys.shiftLeft ---
  // Expected result: 24 (00000000 00011000)
  // push constant 6     // 00000000 00000110
  // push constant 2
  // call Sys.shiftLeft 2

  // --- Test Sys.computeParity ---
  // For input 31 (00000000 00011111), there are five 1's (odd parity).
  // Expected result: 1
  // push constant 31
  // call Sys.computeParity 1

  // --- Test Sys.encode ---
  // For input 31 (00000000 00011111), odd parity means set the MSB.
  // Expected result: 32799 (10000000 00011111)
  push constant 31
  call Sys.encode 1

  return
